var Backend = {	drawNode : undefined,	drawParent : undefined,	cssRuleList : undefined,	cssDoc : undefined,	cssStringifyDoc : undefined,	cssEditorDoc : undefined,	init : function() {		var req, list, i;		this.cssDoc = document.implementation.createDocument(null, "data", null);		this.cssStringifyDoc = DOM.loadDocument("/getTemplate.php/slothsoft/css.stringify");		this.cssEditorDoc = DOM.loadDocument("/getTemplate.php/slothsoft/css.editor");				this.drawParent = document.getElementById("backend-colors");				this.cssRuleList = CSS.getStyleRuleListByProperty(["color", "background-color", "border-color"]);		this.loadCSS();		for (i = 0; i < this.cssRuleList.length; i++) {			this.cssDoc.documentElement.appendChild(CSS.asNode(this.cssRuleList[i], this.cssDoc));		}								//alert(CSS.asNode(CSS.getStyleRuleListByProperty("color")[0], this.cssDoc).childNodes[0].getAttribute("name"));				this.draw();	},	draw : function() {		while (this.drawParent.hasChildNodes()) {			this.drawParent.removeChild(this.drawParent.lastChild);		}		this.drawNode = XSLT.transformToNode(this.cssDoc, this.cssEditorDoc, document);		this.drawParent.appendChild(this.drawNode);				//this.drawNode = XSLT.transformToNode(this.cssDoc, this.cssStringifyDoc, document);		//this.drawParent.appendChild(this.drawNode);	},	setColor : function(node) {		var selector, property, value, ruleList, i;		selector = node.getAttribute("data-css-selector");		property = node.getAttribute("data-css-property");		value = node.value;		ruleList = CSS.getStyleRuleListByProperty([property]);		for (i = 0; i < ruleList.length; i++) {			if (ruleList[i].selectorText === selector) {				ruleList[i].style.setProperty(property, value);			}		}		this.saveCSS();	},	loadCSS : function() {		var i, j, k, obj;		try {			if (window.location.hash.substring(1)) {				obj = JSON.parse(window.location.hash.substring(1));				k = 0;				for (i = 0; i < this.cssRuleList.length; i++) {					for (j = 0; j < this.cssRuleList[i].style.length; j++) {						if (this.cssRuleList[i].style[j].indexOf("color") !== -1) {							if (this.cssRuleList[i].style[j].indexOf("border") === -1) {								this.cssRuleList[i].style.setProperty(this.cssRuleList[i].style[j], obj[k]);							}							k++;						}					}				}			}		} catch(e) {			alert(e);		}	},	saveCSS : function() {		var i, j, obj;		obj = [];		for (i = 0; i < this.cssRuleList.length; i++) {			for (j = 0; j < this.cssRuleList[i].style.length; j++) { 				if (this.cssRuleList[i].style[j].indexOf("color") !== -1) {					obj.push(this.cssRuleList[i].style.getPropertyValue(this.cssRuleList[i].style[j]));				}			}		}		window.location.hash = "#" + JSON.stringify(obj);	},};addEventListener(	"load",	function(eve) {		Backend.init();	},	false);